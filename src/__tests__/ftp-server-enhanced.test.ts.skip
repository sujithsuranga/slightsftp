import { FTPServer } from '../ftp-server';
import { DatabaseManager } from '../database';
import { Listener } from '../types';

describe('FTPServer - Enhanced Tests', () => {
  let db: DatabaseManager;
  let listener: Listener;
  let server: FTPServer;

  beforeEach(async () => {
    db = new DatabaseManager(':memory:');
    await db.init();
    
    // Create test listener
    const listenerId = db.createListener({
      name: 'Test FTP',
      protocol: 'FTP',
      bindingIp: '127.0.0.1',
      port: 0, // Use random port for testing
      enabled: true
    });
    
    listener = db.getListener(listenerId)!;
    server = new FTPServer(listener, db);
  });

  afterEach(async () => {
    if (server) {
      await server.stop();
    }
  });

  describe('Server Initialization', () => {
    test('should create FTP server instance', () => {
      expect(server).toBeDefined();
      expect(server).toBeInstanceOf(FTPServer);
    });

    test('should emit started event on start', (done) => {
      server.on('started', () => {
        expect(true).toBe(true);
        done();
      });

      server.start().catch(() => {
        // Ignore errors for this test
        done();
      });
    });

    test('should emit stopped event on stop', async () => {
      const stopPromise = new Promise<void>((resolve) => {
        server.on('stopped', () => {
          resolve();
        });
      });

      await server.start().catch(() => {});
      await server.stop();
      
      await stopPromise;
      expect(true).toBe(true);
    });
  });

  describe('Session Management', () => {
    test('should track active sessions', () => {
      const sessions = server.getActiveSessions();
      expect(Array.isArray(sessions)).toBe(true);
      expect(sessions).toHaveLength(0);
    });

    test('should return session details', () => {
      const sessions = server.getActiveSessions();
      
      sessions.forEach(session => {
        expect(session).toHaveProperty('sessionId');
        expect(session).toHaveProperty('username');
        expect(session).toHaveProperty('ipAddress');
        expect(session).toHaveProperty('connectedAt');
      });
    });

    test('should handle session disconnect', () => {
      const result = server.disconnectSession('non-existent-session');
      expect(result).toBe(false);
    });
  });

  describe('Authentication', () => {
    test('should require valid credentials', async () => {
      db.createUser({ username: 'testuser', password: 'testpass', passwordEnabled: true, guiEnabled: false });
      const user = db.getUser('testuser');
      
      expect(user).toBeDefined();
      expect(user?.passwordEnabled).toBe(true);
    });

    test('should verify user subscription to listener', () => {
      db.createUser({ username: 'testuser', password: 'testpass', passwordEnabled: true, guiEnabled: false });
      const user = db.getUser('testuser');
      
      if (user && listener.id) {
        if (user.id && listener.id) db.subscribeUserToListener(user.id, listener.id);
        
        const userListeners = if (user.id) db.getUserListeners(user.id);
        expect(userListeners).toContain(listener.id);
      }
    });

    test('should reject user not subscribed to listener', () => {
      db.createUser({ username: 'testuser', password: 'testpass', passwordEnabled: true, guiEnabled: false });
      const user = db.getUser('testuser');
      
      if (user && listener.id) {
        const userListeners = if (user.id) db.getUserListeners(user.id);
        expect(userListeners).not.toContain(listener.id);
      }
    });
  });

  describe('Permissions', () => {
    test('should retrieve user permissions for listener', () => {
      db.createUser({ username: 'testuser', password: 'testpass', passwordEnabled: true, guiEnabled: false });
      const user = db.getUser('testuser');
      
      if (user && listener.id) {
        if (user.id && listener.id) db.subscribeUserToListener(user.id, listener.id);
        if (user.id && listener.id) db.setPermission(user.id, listener.id, {
          canCreate: true,
          canEdit: true,
          canAppend: true,
          canDelete: false,
          canList: true,
          canCreateDir: false,
          canRename: false
        });
        
        const perms = (user.id && listener.id) ? db.getPermission(user.id, listener.id) : undefined;
        expect(perms).toBeDefined();
        expect(perms?.canCreate).toBe(true);
        expect(perms?.canDelete).toBe(false);
      }
    });

    test('should handle missing permissions', () => {
      db.createUser({ username: 'testuser', password: 'testpass', passwordEnabled: true, guiEnabled: false });
      const user = db.getUser('testuser');
      
      if (user && listener.id) {
        const perms = (user.id && listener.id) ? db.getPermission(user.id, listener.id) : undefined;
        expect(perms).toBeUndefined();
      }
    });
  });

  describe('Virtual Paths', () => {
    test('should support user virtual paths', () => {
      db.createUser({ username: 'testuser', password: 'testpass', passwordEnabled: true, guiEnabled: false });
      const user = db.getUser('testuser');
      
      if (user) {
        db.addVirtualPath({
          userId: user.id!,
          virtualPath: '/home',
          localPath: 'C:\\Users\\test',
          canRead: true,
          canWrite: true,
          canAppend: true,
          canDelete: false,
          canList: true,
          canCreateDir: false,
          canRename: false,
          applyToSubdirs: true
        });
        
        const vpaths = if (user.id) db.getVirtualPaths(user.id);
        expect(vpaths).toHaveLength(1);
        expect(vpaths[0].virtualPath).toBe('/home');
      }
    });

    test('should handle multiple virtual paths', () => {
      db.createUser({ username: 'testuser', password: 'testpass', passwordEnabled: true, guiEnabled: false });
      const user = db.getUser('testuser');
      
      if (user) {
        db.addVirtualPath({
          userId: user.id!,
          virtualPath: '/home',
          localPath: 'C:\\Users\\test\\home',
          canRead: true,
          canWrite: true,
          canAppend: true,
          canDelete: false,
          canList: true,
          canCreateDir: false,
          canRename: false,
          applyToSubdirs: true
        });
        
        db.addVirtualPath({
          userId: user.id!,
          virtualPath: '/work',
          localPath: 'C:\\Users\\test\\work',
          canRead: true,
          canWrite: false,
          canAppend: false,
          canDelete: false,
          canList: true,
          canCreateDir: false,
          canRename: false,
          applyToSubdirs: true
        });
        
        const vpaths = if (user.id) db.getVirtualPaths(user.id);
        expect(vpaths).toHaveLength(2);
      }
    });
  });

  describe('Activity Logging', () => {
    test('should log login activity', () => {
      if (listener.id) {
        db.logActivity({
          listenerId: listener.id,
          username: 'testuser',
          action: 'LOGIN',
          path: '/',
          success: true
        });
        
        const activities = db.getRecentActivities(listener.id);
        const loginActivity = activities.find(a => a.action === 'LOGIN');
        expect(loginActivity).toBeDefined();
      }
    });

    test('should log failed login', () => {
      if (listener.id) {
        db.logActivity({
          listenerId: listener.id,
          username: 'testuser',
          action: 'LOGIN_FAILED',
          path: '/',
          success: false
        });
        
        const activities = db.getRecentActivities(listener.id);
        const failedActivity = activities.find(a => a.action === 'LOGIN_FAILED');
        expect(failedActivity).toBeDefined();
        expect(failedActivity?.success).toBe(false);
      }
    });

    test('should log logout activity', () => {
      if (listener.id) {
        db.logActivity({
          listenerId: listener.id,
          username: 'testuser',
          action: 'LOGOUT',
          path: '/',
          success: true
        });
        
        const activities = db.getRecentActivities(listener.id);
        const logoutActivity = activities.find(a => a.action === 'LOGOUT');
        expect(logoutActivity).toBeDefined();
      }
    });

    test('should log file operations', () => {
      if (listener.id) {
        const operations = [
          'FILE_UPLOAD',
          'FILE_DOWNLOAD',
          'FILE_DELETE',
          'DIR_CREATE',
          'FILE_RENAME'
        ];
        
        operations.forEach(op => {
          db.logActivity({
            listenerId: listener.id!,
            username: 'testuser',
            action: op,
            path: '/test/file.txt',
            success: true
          });
        });
        
        const activities = db.getRecentActivities(listener.id);
        expect(activities.length).toBeGreaterThanOrEqual(operations.length);
      }
    });
  });

  describe('Error Handling', () => {
    test('should handle server start failure gracefully', async () => {
      // Create listener with invalid configuration
      const invalidListenerId = db.createListener({
        name: 'Invalid FTP',
        protocol: 'FTP',
        bindingIp: '256.256.256.256', // Invalid IP
        port: 99999, // Invalid port
        enabled: true
      });
      
      const invalidListener = db.getListener(invalidListenerId)!;
      const invalidServer = new FTPServer(invalidListener, db);
      
      await expect(invalidServer.start()).rejects.toThrow();
    });

    test('should handle stop when server not started', async () => {
      await expect(server.stop()).resolves.not.toThrow();
    });

    test('should emit error event on failure', (done) => {
      const invalidListenerId = db.createListener({
        name: 'Invalid FTP',
        protocol: 'FTP',
        bindingIp: '256.256.256.256',
        port: 99999,
        enabled: true
      });
      
      const invalidListener = db.getListener(invalidListenerId)!;
      const invalidServer = new FTPServer(invalidListener, db);
      
      invalidServer.on('error', (err) => {
        expect(err).toBeDefined();
        done();
      });
      
      invalidServer.start().catch(() => {});
    });
  });

  describe('Listener Configuration', () => {
    test('should respect binding IP', () => {
      expect(listener.bindingIp).toBe('127.0.0.1');
    });

    test('should respect port configuration', () => {
      expect(typeof listener.port).toBe('number');
      expect(listener.port).toBeGreaterThanOrEqual(0);
    });

    test('should respect enabled flag', () => {
      expect(listener.enabled).toBe(true);
    });

    test('should have correct protocol', () => {
      expect(listener.protocol).toBe('FTP');
    });
  });

  describe('Connection Management', () => {
    test('should initialize with no active connections', () => {
      expect(server.getActiveSessions()).toHaveLength(0);
    });

    test('should clear sessions on stop', async () => {
      await server.start().catch(() => {});
      await server.stop();
      
      expect(server.getActiveSessions()).toHaveLength(0);
    });
  });

  describe('User Setup', () => {
    test('should create test user with FTP access', () => {
      db.createUser({ username: 'ftpuser', password: 'ftppass', passwordEnabled: true, guiEnabled: false });
      const user = db.getUser('ftpuser');
      
      expect(user).toBeDefined();
      expect(user?.username).toBe('ftpuser');
      expect(user?.passwordEnabled).toBe(true);
    });

    test('should subscribe user to FTP listener', () => {
      db.createUser({ username: 'ftpuser', password: 'ftppass', passwordEnabled: true, guiEnabled: false });
      const user = db.getUser('ftpuser');
      
      if (user && listener.id) {
        if (user.id && listener.id) db.subscribeUserToListener(user.id, listener.id);
        
        const listeners = user.id ? db.getUserListeners(user.id) : [];
        expect(listeners).toContain(listener.id);
      }
    });

    test('should set user permissions', () => {
      db.createUser({ username: 'ftpuser', password: 'ftppass', passwordEnabled: true, guiEnabled: false });
      const user = db.getUser('ftpuser');
      
      if (user && listener.id) {
        if (user.id && listener.id) db.subscribeUserToListener(user.id, listener.id);
        if (user.id && listener.id) db.setPermission(user.id, listener.id, {
          canCreate: true,
          canEdit: true,
          canAppend: true,
          canDelete: true,
          canList: true,
          canCreateDir: true,
          canRename: true
        });
        
        const perms = (user.id && listener.id) ? db.getPermission(user.id, listener.id) : undefined;
        expect(perms?.canDelete).toBe(true);
      }
    });
  });
});
