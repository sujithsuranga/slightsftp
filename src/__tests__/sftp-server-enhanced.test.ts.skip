import { SFTPServer } from '../sftp-server';
import { DatabaseManager } from '../database';
import { Listener } from '../types';

describe('SFTPServer - Enhanced Tests', () => {
  let db: DatabaseManager;
  let listener: Listener;
  let server: SFTPServer;

  beforeEach(async () => {
    db = new DatabaseManager(':memory:');
    await db.init();
    
    // Create test listener
    const listenerId = db.createListener({
      name: 'Test SFTP',
      protocol: 'SFTP',
      bindingIp: '127.0.0.1',
      port: 0, // Use random port for testing
      enabled: true
    });
    
    listener = db.getListener(listenerId)!;
    server = new SFTPServer(listener, db);
  });

  afterEach(async () => {
    if (server) {
      await server.stop();
    }
  });

  describe('Server Initialization', () => {
    test('should create SFTP server instance', () => {
      expect(server).toBeDefined();
      expect(server).toBeInstanceOf(SFTPServer);
    });

    test('should create server with custom idle timeout', () => {
      const customServer = new SFTPServer(listener, db, 60000);
      expect(customServer).toBeDefined();
    });

    test('should generate host keys on initialization', () => {
      // Host keys are generated in constructor
      expect(server).toBeDefined();
    });

    test('should emit started event on start', (done) => {
      server.on('started', () => {
        expect(true).toBe(true);
        done();
      });

      server.start().catch(() => {
        // Ignore errors for this test
        done();
      });
    });

    test('should emit stopped event on stop', async () => {
      const stopPromise = new Promise<void>((resolve) => {
        server.on('stopped', () => {
          resolve();
        });
      });

      await server.start().catch(() => {});
      await server.stop();
      
      await stopPromise;
      expect(true).toBe(true);
    });
  });

  describe('Session Management', () => {
    test('should track active sessions', () => {
      const sessions = server.getActiveSessions();
      expect(Array.isArray(sessions)).toBe(true);
      expect(sessions).toHaveLength(0);
    });

    test('should return session details', () => {
      const sessions = server.getActiveSessions();
      
      sessions.forEach(session => {
        expect(session).toHaveProperty('sessionId');
        expect(session).toHaveProperty('username');
        expect(session).toHaveProperty('ipAddress');
        expect(session).toHaveProperty('connectedAt');
      });
    });

    test('should handle session disconnect', () => {
      const result = server.disconnectSession('non-existent-session');
      expect(result).toBe(false);
    });

    test('should initialize with no active connections', () => {
      expect(server.getActiveSessions()).toHaveLength(0);
    });

    test('should clear sessions on stop', async () => {
      await server.start().catch(() => {});
      await server.stop();
      
      expect(server.getActiveSessions()).toHaveLength(0);
    });
  });

  describe('Authentication - Password', () => {
    test('should support password authentication', async () => {
      db.createUser({ username: 'testuser', password: 'testpass', passwordEnabled: true, guiEnabled: false });
      const user = db.getUser('testuser');
      
      expect(user).toBeDefined();
      expect(user?.passwordEnabled).toBe(true);
    });

    test('should verify password correctly', () => {
      db.createUser({ username: 'testuser', password: 'testpass', passwordEnabled: true, guiEnabled: false });
      
      expect(db.verifyPassword('testuser', 'testpass')).toBe(true);
      expect(db.verifyPassword('testuser', 'wrongpass')).toBe(false);
    });

    test('should require valid credentials', () => {
      const user = db.getUser('nonexistent');
      expect(user).toBeNull();
    });

    test('should verify user subscription to listener', () => {
      db.createUser({ username: 'testuser', password: 'testpass', passwordEnabled: true, guiEnabled: false });
      const user = db.getUser('testuser');
      
      if (user && listener.id) {
        if (user.id && listener.id) db.subscribeUserToListener(user.id, listener.id);
        
        const userListeners = user.id ? db.getUserListeners(user.id) : [];
        expect(userListeners).toContain(listener.id);
      }
    });

    test('should reject user not subscribed to listener', () => {
      db.createUser({ username: 'testuser', password: 'testpass', passwordEnabled: true, guiEnabled: false });
      const user = db.getUser('testuser');
      
      if (user && listener.id) {
        const userListeners = user.id ? db.getUserListeners(user.id) : [];
        expect(userListeners).not.toContain(listener.id);
      }
    });
  });

  describe('Authentication - Public Key', () => {
    test('should support public key authentication', () => {
      const publicKey = 'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTest...';
      db.createUser({ username: 'keyuser', password: undefined, passwordEnabled: false, guiEnabled: false });
      const user = db.getUser('keyuser');
      
      if (user) {
        db.updateUser('keyuser', { publicKey });
        const updated = db.getUser('keyuser');
        expect(updated?.publicKey).toBe(publicKey);
      }
    });

    test('should handle user without public key', () => {
      db.createUser({ username: 'nokey', password: 'password', passwordEnabled: true, guiEnabled: false });
      const user = db.getUser('nokey');
      
      expect(user?.publicKey).toBeNull();
    });
  });

  describe('Permissions', () => {
    test('should retrieve user permissions for listener', () => {
      db.createUser({ username: 'testuser', password: 'testpass', passwordEnabled: true, guiEnabled: false });
      const user = db.getUser('testuser');
      
      if (user && listener.id) {
        if (user.id && listener.id) db.subscribeUserToListener(user.id, listener.id);
        if (user.id && listener.id) db.setPermission(user.id, listener.id, {
          canCreate: true,
          canEdit: true,
          canAppend: true,
          canDelete: false,
          canList: true,
          canCreateDir: false,
          canRename: false
        });
        
        const perms = (user.id && listener.id) ? db.getPermission(user.id, listener.id) : undefined;
        expect(perms).toBeDefined();
        expect(perms?.canCreate).toBe(true);
        expect(perms?.canDelete).toBe(false);
      }
    });

    test('should handle missing permissions', () => {
      db.createUser({ username: 'testuser', password: 'testpass', passwordEnabled: true, guiEnabled: false });
      const user = db.getUser('testuser');
      
      if (user && listener.id) {
        const perms = (user.id && listener.id) ? db.getPermission(user.id, listener.id) : undefined;
        expect(perms).toBeUndefined();
      }
    });

    test('should set full permissions', () => {
      db.createUser({ username: 'testuser', password: 'testpass', passwordEnabled: true, guiEnabled: false });
      const user = db.getUser('testuser');
      
      if (user && listener.id) {
        if (user.id && listener.id) db.subscribeUserToListener(user.id, listener.id);
        if (user.id && listener.id) db.setPermission(user.id, listener.id, {
          canCreate: true,
          canEdit: true,
          canAppend: true,
          canDelete: true,
          canList: true,
          canCreateDir: true,
          canRename: true
        });
        
        const perms = (user.id && listener.id) ? db.getPermission(user.id, listener.id) : undefined;
        expect(perms?.canDelete).toBe(true);
        expect(perms?.canCreateDir).toBe(true);
        expect(perms?.canRename).toBe(true);
      }
    });
  });

  describe('Virtual Paths', () => {
    test('should support user virtual paths', () => {
      db.createUser({ username: 'testuser', password: 'testpass', passwordEnabled: true, guiEnabled: false });
      const user = db.getUser('testuser');
      
      if (user) {
        db.addVirtualPath({
          userId: user.id!,
          virtualPath: '/home',
          localPath: 'C:\\Users\\test',
          canRead: true,
          canWrite: true,
          canAppend: true,
          canDelete: false,
          canList: true,
          canCreateDir: false,
          canRename: false,
          applyToSubdirs: true
        });
        
        const vpaths = user.id ? db.getVirtualPaths(user.id) : [];
        expect(vpaths).toHaveLength(1);
        expect(vpaths[0].virtualPath).toBe('/home');
      }
    });

    test('should handle multiple virtual paths', () => {
      db.createUser({ username: 'testuser', password: 'testpass', passwordEnabled: true, guiEnabled: false });
      const user = db.getUser('testuser');
      
      if (user) {
        db.addVirtualPath({
          userId: user.id!,
          virtualPath: '/home',
          localPath: 'C:\\Users\\test\\home',
          canRead: true,
          canWrite: true,
          canAppend: true,
          canDelete: false,
          canList: true,
          canCreateDir: false,
          canRename: false,
          applyToSubdirs: true
        });
        
        db.addVirtualPath({
          userId: user.id!,
          virtualPath: '/work',
          localPath: 'C:\\Users\\test\\work',
          canRead: true,
          canWrite: false,
          canAppend: false,
          canDelete: false,
          canList: true,
          canCreateDir: false,
          canRename: false,
          applyToSubdirs: true
        });
        
        const vpaths = user.id ? db.getVirtualPaths(user.id) : [];
        expect(vpaths).toHaveLength(2);
      }
    });

    test('should support read-only virtual paths', () => {
      db.createUser({ username: 'readonly', password: 'pass', passwordEnabled: true, guiEnabled: false });
      const user = db.getUser('readonly');
      
      if (user) {
        db.addVirtualPath({
          userId: user.id!,
          virtualPath: '/readonly',
          localPath: 'C:\\ReadOnly',
          canRead: true,
          canWrite: false,
          canAppend: false,
          canDelete: false,
          canList: true,
          canCreateDir: false,
          canRename: false,
          applyToSubdirs: true
        });
        
        const vpaths = user.id ? db.getVirtualPaths(user.id) : [];
        expect(vpaths[0].canWrite).toBe(false);
        expect(vpaths[0].canDelete).toBe(false);
      }
    });
  });

  describe('Activity Logging', () => {
    test('should emit activity events', (done) => {
      server.on('activity', (activity) => {
        expect(activity).toHaveProperty('listenerId');
        expect(activity).toHaveProperty('username');
        expect(activity).toHaveProperty('action');
        expect(activity).toHaveProperty('path');
        expect(activity).toHaveProperty('success');
        done();
      });

      // Simulate activity
      server.emit('activity', {
        listenerId: listener.id!,
        username: 'testuser',
        action: 'LOGIN',
        path: '/',
        success: true
      });
    });

    test('should log login activity', () => {
      if (listener.id) {
        db.logActivity({
          listenerId: listener.id,
          username: 'testuser',
          action: 'LOGIN',
          path: '/',
          success: true
        });
        
        const activities = db.getRecentActivities(listener.id);
        const loginActivity = activities.find(a => a.action === 'LOGIN');
        expect(loginActivity).toBeDefined();
      }
    });

    test('should log failed login', () => {
      if (listener.id) {
        db.logActivity({
          listenerId: listener.id,
          username: 'testuser',
          action: 'LOGIN_FAILED',
          path: '/',
          success: false
        });
        
        const activities = db.getRecentActivities(listener.id);
        const failedActivity = activities.find(a => a.action === 'LOGIN_FAILED');
        expect(failedActivity).toBeDefined();
        expect(failedActivity?.success).toBe(false);
      }
    });

    test('should log file operations', () => {
      if (listener.id) {
        const operations = [
          'FILE_UPLOAD',
          'FILE_DOWNLOAD',
          'FILE_DELETE',
          'DIR_CREATE',
          'FILE_RENAME'
        ];
        
        operations.forEach(op => {
          db.logActivity({
            listenerId: listener.id!,
            username: 'testuser',
            action: op,
            path: '/test/file.txt',
            success: true
          });
        });
        
        const activities = db.getRecentActivities(listener.id);
        expect(activities.length).toBeGreaterThanOrEqual(operations.length);
      }
    });
  });

  describe('Error Handling', () => {
    test('should handle server start failure gracefully', async () => {
      // Create listener with invalid configuration
      const invalidListenerId = db.createListener({
        name: 'Invalid SFTP',
        protocol: 'SFTP',
        bindingIp: '256.256.256.256', // Invalid IP
        port: 99999, // Invalid port
        enabled: true
      });
      
      const invalidListener = db.getListener(invalidListenerId)!;
      const invalidServer = new SFTPServer(invalidListener, db);
      
      await expect(invalidServer.start()).rejects.toThrow();
    });

    test('should handle stop when server not started', async () => {
      await expect(server.stop()).resolves.not.toThrow();
    });

    test('should emit error event on failure', (done) => {
      const invalidListenerId = db.createListener({
        name: 'Invalid SFTP',
        protocol: 'SFTP',
        bindingIp: '256.256.256.256',
        port: 99999,
        enabled: true
      });
      
      const invalidListener = db.getListener(invalidListenerId)!;
      const invalidServer = new SFTPServer(invalidListener, db);
      
      invalidServer.on('error', (err) => {
        expect(err).toBeDefined();
        done();
      });
      
      invalidServer.start().catch(() => {});
    });
  });

  describe('Listener Configuration', () => {
    test('should respect binding IP', () => {
      expect(listener.bindingIp).toBe('127.0.0.1');
    });

    test('should respect port configuration', () => {
      expect(typeof listener.port).toBe('number');
      expect(listener.port).toBeGreaterThanOrEqual(0);
    });

    test('should respect enabled flag', () => {
      expect(listener.enabled).toBe(true);
    });

    test('should have correct protocol', () => {
      expect(listener.protocol).toBe('SFTP');
    });
  });

  describe('User Setup', () => {
    test('should create test user with SFTP access', () => {
      db.createUser({ username: 'sftpuser', password: 'sftppass', passwordEnabled: true, guiEnabled: false });
      const user = db.getUser('sftpuser');
      
      expect(user).toBeDefined();
      expect(user?.username).toBe('sftpuser');
      expect(user?.passwordEnabled).toBe(true);
    });

    test('should subscribe user to SFTP listener', () => {
      db.createUser({ username: 'sftpuser', password: 'sftppass', passwordEnabled: true, guiEnabled: false });
      const user = db.getUser('sftpuser');
      
      if (user && listener.id) {
        if (user.id && listener.id) db.subscribeUserToListener(user.id, listener.id);
        
        const listeners = user.id ? db.getUserListeners(user.id) : [];
        expect(listeners).toContain(listener.id);
      }
    });

    test('should set user permissions', () => {
      db.createUser({ username: 'sftpuser', password: 'sftppass', passwordEnabled: true, guiEnabled: false });
      const user = db.getUser('sftpuser');
      
      if (user && listener.id) {
        if (user.id && listener.id) db.subscribeUserToListener(user.id, listener.id);
        if (user.id && listener.id) db.setPermission(user.id, listener.id, {
          canCreate: true,
          canEdit: true,
          canAppend: true,
          canDelete: true,
          canList: true,
          canCreateDir: true,
          canRename: true
        });
        
        const perms = (user.id && listener.id) ? db.getPermission(user.id, listener.id) : undefined;
        expect(perms?.canDelete).toBe(true);
      }
    });
  });

  describe('Idle Timeout', () => {
    test('should accept custom idle timeout', () => {
      const customTimeout = 120000; // 2 minutes
      const customServer = new SFTPServer(listener, db, customTimeout);
      
      expect(customServer).toBeDefined();
    });

    test('should use default timeout when not specified', () => {
      const defaultServer = new SFTPServer(listener, db);
      
      expect(defaultServer).toBeDefined();
    });
  });

  describe('SFTP Protocol Operations', () => {
    test('should support REALPATH operation', () => {
      // REALPATH is a core SFTP operation
      expect(true).toBe(true);
    });

    test('should support STAT operation', () => {
      // STAT is a core SFTP operation
      expect(true).toBe(true);
    });

    test('should support OPENDIR operation', () => {
      // OPENDIR is a core SFTP operation
      expect(true).toBe(true);
    });

    test('should support READDIR operation', () => {
      // READDIR is a core SFTP operation
      expect(true).toBe(true);
    });

    test('should support OPEN operation', () => {
      // OPEN is a core SFTP operation
      expect(true).toBe(true);
    });

    test('should support READ operation', () => {
      // READ is a core SFTP operation
      expect(true).toBe(true);
    });

    test('should support WRITE operation', () => {
      // WRITE is a core SFTP operation
      expect(true).toBe(true);
    });

    test('should support MKDIR operation', () => {
      // MKDIR is a core SFTP operation
      expect(true).toBe(true);
    });

    test('should support REMOVE operation', () => {
      // REMOVE is a core SFTP operation
      expect(true).toBe(true);
    });

    test('should support RENAME operation', () => {
      // RENAME is a core SFTP operation
      expect(true).toBe(true);
    });
  });
});

